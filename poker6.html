<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker Texas Hold'em Avançado</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        #game {
            max-width: 800px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        .card, .card-back {
            display: inline-block;
            width: 50px; /* Largura da carta */
            height: 70px; /* Altura da carta */
            border: 1px solid #333;
            border-radius: 5px;
            margin: 2px;
            text-align: center;
            line-height: 70px;
            font-size: 20px;
            background-color: #fff; /* Cor de fundo para cartas abertas */
            color: #000;
        }
        .card-back {
            background-color: #007bff; /* Cor de fundo azul para cartas fechadas */
            background-image: url('card-back.png'); /* Imagem de fundo */
            background-size: cover; /* Garante que a imagem cubra todo o espaço */
        }
        .red {
            color: #e74c3c;
        }
        .player-area {
            background-color: #ecf0f1;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 5px;
        }
        .current-player {
            background-color: #3498db;
            color: #fff;
        }
        .folded-player {
            background-color: #95a5a6;
            color: #fff;
        }
        button {
            background-color: #2ecc71;
            color: #fff;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        input[type="number"] {
            width: 60px;
            padding: 5px;
        }
        #result {
            margin-top: 20px;
            font-weight: bold;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div id="game">
        <h1>Poker Texas Hold'em Avançado</h1>
        <div id="community-cards"></div>
        <div id="players"></div>
        <div id="pot"></div>
        <div id="betting-round"></div>
        <div id="betting-actions">
            <button id="check">Check</button>
            <button id="call">Call</button>
            <button id="bet">Bet</button>
            <input type="number" id="bet-amount" min="1" value="10">
            <button id="fold">Fold</button>
        </div>
        <button id="deal">Iniciar Novo Jogo</button>
        <div id="result"></div>
    </div>

    <script>
        const suits = ['♠', '♥', '♦', '♣'];
        const cardValues = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        let deck = [];
        let communityCards = [];
        let players = [];
        let currentPlayerIndex = 0;
        let pot = 0;
        let currentBet = 0;
        let currentBettingRound = 0;

        function createDeck() {
            deck = [];
            for (let suit of suits) {
                for (let value of cardValues) {
                    deck.push(value + suit);
                }
        }
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function dealCards() {
            createDeck();
            shuffle(deck);

            players = [
                { name: "Você", hand: [], chips: 1000, bet: 0, folded: false, isHuman: true },
                { name: "Computador 1", hand: [], chips: 1000, bet: 0, folded: false, isHuman: false },
                { name: "Computador 2", hand: [], chips: 1000, bet: 0, folded: false, isHuman: false },
                { name: "Computador 3", hand: [], chips: 1000, bet: 0, folded: false, isHuman: false }
            ];

            communityCards = deck.slice(0, 5);
            deck = deck.slice(5);

            pot = 0;
            currentBet = 0;
            currentBettingRound = 0;
            currentPlayerIndex = 1; // Start with the player after the dealer

            updateUI();
            setTimeout(startInitialBettingRound, 1000); // Delay to show initial bets
        }

        function updateUI() {
            document.getElementById('community-cards').innerHTML = 'Cartas comunitárias: ' +
                communityCards.slice(0, 3 + currentBettingRound).map(formatCard).join('');
            document.getElementById('players').innerHTML = players.map((player, index) => {
                const playerChips = player.chips !== undefined && player.chips >= 0 ? player.chips : 0;
                return `
                    <div class="player-area ${index === currentPlayerIndex ? 'current-player' : ''} ${player.folded ? 'folded-player' : ''}">
                        <strong>${player.name}</strong> (${playerChips} fichas)
                        ${player.folded ? ' (Desistiu)' : ''}
                        ${index === currentPlayerIndex ? ' (Jogando)' : ''}
                        <br>
                        Mão: ${player.hand.map(card => card === 'back' ? formatCard(card) : formatCard(card)).join('')}
                        <br>
                        Aposta atual: ${player.bet || 0}
                    </div>
                `;
            }).join(''); 
            document.getElementById('pot').innerHTML = `Pote: ${pot}`;
            document.getElementById('betting-round').innerHTML = `Rodada de apostas: ${['Pré-flop', 'Flop', 'Turn', 'River'][currentBettingRound]}`;
            const currentPlayer = players[currentPlayerIndex];
            const canCheck = currentPlayer.bet === currentBet;
            document.getElementById('check').disabled = !canCheck || !currentPlayer.isHuman;
            document.getElementById('call').disabled = canCheck || !currentPlayer.isHuman;
            document.getElementById('bet').disabled = !currentPlayer.isHuman;
            document.getElementById('bet-amount').disabled = !currentPlayer.isHuman;
            document.getElementById('fold').disabled = !currentPlayer.isHuman;
        }

        function formatCard(card) {
            if (card === 'back') {
                return '<div class="card-back" style="display: inline-block;"></div>';
            } else {
                const isRed = card.includes('♥') || card.includes('♦');
                return `<div class="card ${isRed ? 'red' : ''}">${card}</div>`;
            }
        }

        function startInitialBettingRound() {
            currentPlayerIndex = 0; // Start with the human player
            updateUI();
            if (!players[currentPlayerIndex].isHuman) {
                setTimeout(computerAction, 1000);
            }
        }

        function startBettingRound() {
            for (let i = 0; i < players.length; i++) {
                if (players[i].isHuman) {
                    players[i].hand = [deck.pop(), deck.pop()];
                } else {
                    players[i].hand = ['back', 'back'];
                }
            }
            currentPlayerIndex = (currentPlayerIndex + 1) % players.length; // Move to the next player
            for (let player of players) {
                player.bet = 0;
            }
            currentBet = 0;
            updateUI();
            if (!players[currentPlayerIndex].isHuman) {
                setTimeout(computerAction, 1000);
            }
        }

        function nextPlayer() {
            do {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
            } while (players[currentPlayerIndex].folded && players.some(p => !p.folded));

            if (checkRoundEnd()) {
                if (currentBettingRound < 3) {
                    currentBettingRound++;
                    startBettingRound();
                } else {
                    showdown();
                }
            } else {
                updateUI();
                if (!players[currentPlayerIndex].isHuman) {
                    setTimeout(computerAction, 1000);
                }
            }
        }

        function checkRoundEnd() {
            const activePlayers = players.filter(p => !p.folded);
            const allEqualBets = activePlayers.every(p => p.bet === currentBet);
            return allEqualBets;
        }

        function placeBet(amount) {
            const player = players[currentPlayerIndex];
            const actualBet = Math.min(amount, player.chips || 0);
            player.chips = Math.max(0, (player.chips || 0) - actualBet);
            player.bet += actualBet;
            pot += actualBet;
            currentBet = Math.max(currentBet, player.bet);
            nextPlayer();
        }

        function evaluateHand(hand, communityCards) {
            const allCards = [...hand, ...communityCards];
            
            const valueCounts = {};
            for (let card of allCards) {
                const value = card.slice(0, -1);
                valueCounts[value] = (valueCounts[value] || 0) + 1;
            }

            const suitCounts = {};
            for (let card of allCards) {
                const suit = card.slice(-1);
                suitCounts[suit] = (suitCounts[suit] || 0) + 1;
            }
            const hasFlush = Object.values(suitCounts).some(count => count >= 5);

            const uniqueValues = [...new Set(allCards.map(card => cardValues.indexOf(card.slice(0, -1))))];
            uniqueValues.sort((a, b) => a - b);
            let hasStrait = false;
            for (let i = 0; i < uniqueValues.length - 4; i++) {
                if (uniqueValues[i+4] - uniqueValues[i] === 4) {
                    hasStrait = true;
                    break;
                }
            }

            if (hasFlush && hasStrait) return { strength: 8, hand: getBestHand(allCards, valueCounts, suitCounts, 'Straight Flush') };
            if (Object.values(valueCounts).includes(4)) return { strength: 7, hand: getBestHand(allCards, valueCounts, suitCounts, 'Four of a Kind') };
            if (Object.values(valueCounts).includes(3) && Object.values(valueCounts).includes(2)) return { strength: 6, hand: getBestHand(allCards, valueCounts, suitCounts, 'Full House') };
            if (hasFlush) return { strength: 5, hand: getBestHand(allCards, valueCounts, suitCounts, 'Flush') };
            if (hasStrait) return { strength: 4, hand: getBestHand(allCards, valueCounts, suitCounts, 'Straight') };
            if (Object.values(valueCounts).includes(3)) return { strength: 3, hand: getBestHand(allCards, valueCounts, suitCounts, 'Three of a Kind') };
            if (Object.values(valueCounts).filter(count => count === 2).length === 2) return { strength: 2, hand: getBestHand(allCards, valueCounts, suitCounts, 'Two Pair') };
            if (Object.values(valueCounts).includes(2)) return { strength: 1, hand: getBestHand(allCards, valueCounts, suitCounts, 'One Pair') };
            return { strength: 0, hand: getBestHand(allCards, valueCounts, suitCounts, 'High Card') };
        }

        function computerAction() {
            const player = players[currentPlayerIndex];
            const handStrength = evaluateHand(player.hand, communityCards.slice(0, 3 + currentBettingRound));
            const random = Math.random();

            let raiseChance, callChance;

            if (handStrength >= 5) {
                raiseChance = 0.7;
                callChance = 0.25;
            } else if (handStrength >= 3) {
                raiseChance = 0.4;
                callChance = 0.4;
            } else if (handStrength >= 1) {
                raiseChance = 0.2;
                callChance = 0.5;
            } else {
                raiseChance = 0.1;
                callChance = 0.3;
            }

            if (random < raiseChance) {
                const raiseAmount = Math.floor((handStrength + 1) * 10);
                placeBet(currentBet - player.bet + raiseAmount);
            } else if (random < raiseChance + callChance) {
                placeBet(currentBet - player.bet);
            } else {
                player.folded = true;
                nextPlayer();
            }
        }

        function showdown() {
            const activePlayers = players.filter(p => !p.folded);
            const handStrengths = activePlayers.map(player => ({
                player,
                ...evaluateHand(player.hand, communityCards)
            }));

            handStrengths.sort((a, b) => b.strength - a.strength);

            const winner = handStrengths[0].player;
            winner.chips += pot;

            let resultMessage = `Resultado do showdown:<br>${winner.name} ganhou ${pot} fichas com `;
            resultMessage += handStrengths.map(hs => `<br>${hs.player.name} tinha (Melhor mão: ${hs.hand.map(formatCard).join('')})`).join('');
            switch(handStrengths[0].strength) {
                case 8: resultMessage += "um Straight Flush!"; break;
                case 7: resultMessage += "uma Quadra!"; break;
                case 6: resultMessage += "um Full House!"; break;
                case 5: resultMessage += "um Flush!"; break;
                case 4: resultMessage += "um Straight!"; break;
                case 3: resultMessage += "uma Trinca!"; break;
                case 2: resultMessage += "Dois Pares!"; break;
                case 1: resultMessage += "um Par!"; break;
                case 0: resultMessage += "Carta Alta!"; break;
            }
            resultMessage += `<br>Melhor mão: ${handStrengths[0].hand.map(formatCard).join('')}`;
            document.getElementById('community-cards').innerHTML = 'Cartas comunitárias: ' + communityCards.map(formatCard).join('');
            document.getElementById('result').innerHTML = resultMessage;
            updateUI();
            logGameResult(resultMessage);
        }

        function logGameResult(resultMessage) {
            console.log(resultMessage.replace(/<br>/g, '\n').replace(/<[^>]+>/g, ''));
        }

        document.getElementById('deal').addEventListener('click', dealCards);
        document.getElementById('check').addEventListener('click', () => nextPlayer());
        document.getElementById('call').addEventListener('click', () => placeBet(currentBet - players[currentPlayerIndex].bet));
        document.getElementById('bet').addEventListener('click', () => {
            const betAmount = parseInt(document.getElementById('bet-amount').value);
            placeBet(currentBet - players[currentPlayerIndex].bet + betAmount);
        });
        document.getElementById('fold').addEventListener('click', () => {
            players[currentPlayerIndex].folded = true;
            nextPlayer();
        });
        function getBestHand(allCards, valueCounts, suitCounts, handType) {
            const cardValueOrder = cardValues.concat(cardValues).slice(0, 14); // To handle Ace as both high and low
            const sortedCards = allCards.sort((a, b) => cardValueOrder.indexOf(b.slice(0, -1)) - cardValueOrder.indexOf(a.slice(0, -1)));

            if (handType === 'Straight Flush' || handType === 'Flush') {
                const flushSuit = Object.keys(suitCounts).find(suit => suitCounts[suit] >= 5);
                return sortedCards.filter(card => card.endsWith(flushSuit)).slice(0, 5);
            }

            if (handType === 'Four of a Kind') {
                const fourValue = Object.keys(valueCounts).find(value => valueCounts[value] === 4);
                const kicker = sortedCards.find(card => !card.startsWith(fourValue));
                return sortedCards.filter(card => card.startsWith(fourValue)).concat(kicker).slice(0, 5);
            }

            if (handType === 'Full House') {
                const threeValue = Object.keys(valueCounts).find(value => valueCounts[value] === 3);
                const pairValue = Object.keys(valueCounts).find(value => valueCounts[value] === 2);
                return sortedCards.filter(card => card.startsWith(threeValue)).concat(sortedCards.filter(card => card.startsWith(pairValue)).slice(0, 2));
            }

            if (handType === 'Straight') {
                for (let i = 0; i < sortedCards.length - 4; i++) {
                    const straight = sortedCards.slice(i, i + 5);
                    const values = straight.map(card => cardValueOrder.indexOf(card.slice(0, -1)));
                    if (values[0] - values[4] === 4) return straight;
                }
            }

            if (handType === 'Three of a Kind') {
                const threeValue = Object.keys(valueCounts).find(value => valueCounts[value] === 3);
                const kickers = sortedCards.filter(card => !card.startsWith(threeValue)).slice(0, 2);
                return sortedCards.filter(card => card.startsWith(threeValue)).concat(kickers);
            }

            if (handType === 'Two Pair') {
                const pairs = Object.keys(valueCounts).filter(value => valueCounts[value] === 2).sort((a, b) => cardValueOrder.indexOf(b) - cardValueOrder.indexOf(a));
                const kicker = sortedCards.find(card => !pairs.some(pair => card.startsWith(pair)));
                return sortedCards.filter(card => pairs.some(pair => card.startsWith(pair))).concat(kicker).slice(0, 5);
            }

            if (handType === 'One Pair') {
                const pairValue = Object.keys(valueCounts).find(value => valueCounts[value] === 2);
                const kickers = sortedCards.filter(card => !card.startsWith(pairValue)).slice(0, 3);
                return sortedCards.filter(card => card.startsWith(pairValue)).concat(kickers);
            }

            return sortedCards.slice(0, 5); // High Card
        }
    </script>
</body>
</html>
